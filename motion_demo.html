<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>GameFit 動作比對 Demo（深蹲教練 vs 挑戰者）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- 簡單內嵌 CSS -->
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #020617;
      color: #f9fafb;
      display: flex;
      justify-content: center;
      padding: 12px;
    }
    #app { max-width: 480px; width: 100%; }

    h1 {
      font-size: 18px;
      text-align: center;
      margin-bottom: 8px;
    }

    #video-container {
      position: relative;
      width: 100%;
      aspect-ratio: 9 / 16;
      background: #000;
      border-radius: 16px;
      overflow: hidden;
      border: 1px solid #1f2937;
    }

    #video, #overlay {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    #overlay { background: transparent; }

    #hud {
      position: absolute;
      left: 0; right: 0; bottom: 0;
      padding: 6px 8px 8px;
      background: linear-gradient(
        to top,
        rgba(15, 23, 42, 0.95),
        rgba(15, 23, 42, 0)
      );
      font-size: 11px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    #hud .row {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      align-items: center;
    }
    #hud .label { color: #9ca3af; }
    #hud .value { font-weight: 600; color: #38bdf8; }
    #hud .value.big { font-size: 16px; }
    #hud .tag {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid #4b5563;
    }
    #hud .tag.ok { border-color: #22c55e; color: #bbf7d0; }
    #hud .tag.none { border-color: #6b7280; color: #e5e7eb; }

    #controls {
      margin-top: 8px;
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: center;
    }
    button {
      padding: 6px 10px;
      font-size: 12px;
      border-radius: 999px;
      border: 1px solid #4b5563;
      background: #0f172a;
      color: #e5e7eb;
      cursor: pointer;
    }
    button.primary {
      border-color: #38bdf8;
      background: #0b1120;
    }
    button.danger {
      border-color: #f97316;
    }
    button:disabled {
      opacity: 0.4;
      cursor: default;
    }

    #info {
      margin-top: 8px;
      font-size: 11px;
      color: #9ca3af;
      line-height: 1.4;
      text-align: left;
    }
    #score {
      margin-top: 4px;
      font-size: 13px;
      font-weight: 600;
      text-align: center;
    }
  </style>

  <!-- TensorFlow.js + Pose Detection -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
</head>

<body>
  <div id="app">
    <h1>GameFit 動作比對 Demo</h1>

    <div id="video-container">
      <video id="video" playsinline></video>
      <canvas id="overlay"></canvas>

      <div id="hud">
        <div class="row">
          <span class="label">狀態：</span>
          <span id="status" class="value">初始化中…</span>
        </div>
        <div class="row">
          <span class="label">左膝角度：</span>
          <span id="angle" class="value big">--</span><span class="unit">°</span>
        </div>
        <div class="row">
          <span class="label">教練動作：</span>
          <span id="coachTag" class="tag none">尚未錄製</span>
          <span class="label">挑戰者：</span>
          <span id="playerTag" class="tag none">尚未錄製</span>
        </div>
      </div>
    </div>

    <div id="controls">
      <button id="recordCoachBtn" class="primary">錄製教練（3 秒）</button>
      <button id="recordPlayerBtn" class="primary" disabled>錄製挑戰者（3 秒）</button>
      <button id="resetBtn" class="danger">清除紀錄</button>
    </div>

    <div id="score"></div>

    <div id="info">
      使用說明：<br>
      1. 拿著手機退後一點，讓全身入鏡（至少看到髖關節、膝蓋、腳踝）。<br>
      2. 按「錄製教練（3 秒）」做一個完整深蹲。<br>
      3. 之後按「錄製挑戰者（3 秒）」再做一次深蹲。<br>
      4. 系統會用膝蓋角度曲線比對兩次動作，計算「動作相似度」。<br>
    </div>
  </div>

  <script>
    const video = document.getElementById("video");
    const canvas = document.getElementById("overlay");
    const ctx = canvas.getContext("2d");

    const statusEl = document.getElementById("status");
    const angleEl = document.getElementById("angle");
    const coachTag = document.getElementById("coachTag");
    const playerTag = document.getElementById("playerTag");
    const scoreEl = document.getElementById("score");

    const recordCoachBtn = document.getElementById("recordCoachBtn");
    const recordPlayerBtn = document.getElementById("recordPlayerBtn");
    const resetBtn = document.getElementById("resetBtn");

    let detector = null;
    let lastStream = null;

    let mode = "idle"; // idle | recordCoach | recordPlayer
    const RECORD_MS = 3000;
    let recordStartTime = 0;

    let coachAngles = [];
    let playerAngles = [];

    const adjacentPairs = [
      ["left_shoulder", "right_shoulder"],
      ["left_shoulder", "left_elbow"],
      ["left_elbow", "left_wrist"],
      ["right_shoulder", "right_elbow"],
      ["right_elbow", "right_wrist"],
      ["left_shoulder", "left_hip"],
      ["right_shoulder", "right_hip"],
      ["left_hip", "right_hip"],
      ["left_hip", "left_knee"],
      ["left_knee", "left_ankle"],
      ["right_hip", "right_knee"],
      ["right_knee", "right_ankle"]
    ];

    function angleBetween(a, b, c) {
      const ab = { x: a.x - b.x, y: a.y - b.y };
      const cb = { x: c.x - b.x, y: c.y - b.y };
      const dot = ab.x * cb.x + ab.y * cb.y;
      const magAB = Math.hypot(ab.x, ab.y);
      const magCB = Math.hypot(cb.x, cb.y);
      if (!magAB || !magCB) return 0;
      const cos = dot / (magAB * magCB);
      const clamped = Math.max(-1, Math.min(1, cos));
      return (Math.acos(clamped) * 180) / Math.PI;
    }

    function resizeCanvas() {
      canvas.width = video.videoWidth || 360;
      canvas.height = video.videoHeight || 640;
    }

    async function setupCamera() {
      if (lastStream) lastStream.getTracks().forEach(t => t.stop());

      statusEl.textContent = "啟動相機…";

      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "environment" }, // 後鏡頭比較好拍全身
        audio: false
      });

      lastStream = stream;
      video.srcObject = stream;

      return new Promise(resolve => {
        video.onloadedmetadata = () => {
          video.play();
          resizeCanvas();
          resolve();
        };
      });
    }

    function drawPose(keypoints) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!keypoints) return;

      const toScreen = (kp) => ({
        x: (kp.x / video.videoWidth) * canvas.width,
        y: (kp.y / video.videoHeight) * canvas.height
      });

      ctx.save();
      ctx.lineWidth = 4;
      ctx.strokeStyle = "#38bdf8";
      ctx.shadowColor = "#38bdf8";
      ctx.shadowBlur = 12;
      ctx.beginPath();
      adjacentPairs.forEach(([aName, bName]) => {
        const a = keypoints.find(k => k.name === aName || k.part === aName);
        const b = keypoints.find(k => k.name === bName || k.part === bName);
        if (!a || !b || a.score < 0.3 || b.score < 0.3) return;
        const sa = toScreen(a);
        const sb = toScreen(b);
        ctx.moveTo(sa.x, sa.y);
        ctx.lineTo(sb.x, sb.y);
      });
      ctx.stroke();
      ctx.restore();

      keypoints.forEach(kp => {
        if (kp.score < 0.3) return;
        const { x, y } = toScreen(kp);

        ctx.save();
        ctx.fillStyle = "rgba(56,189,248,0.25)";
        ctx.shadowColor = "#38bdf8";
        ctx.shadowBlur = 14;
        ctx.beginPath();
        ctx.arc(x, y, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        ctx.save();
        ctx.fillStyle = "#38bdf8";
        ctx.beginPath();
        ctx.arc(x, y, 3.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }

    function computeKneeAngle(keypoints) {
      const hip = keypoints.find(k => k.name === "left_hip" || k.part === "left_hip");
      const knee = keypoints.find(k => k.name === "left_knee" || k.part === "left_knee");
      const ankle = keypoints.find(k => k.name === "left_ankle" || k.part === "left_ankle");

      if (!hip || !knee || !ankle ||
          hip.score < 0.3 || knee.score < 0.3 || ankle.score < 0.3) {
        return null;
      }

      return angleBetween(
        { x: hip.x, y: hip.y },
        { x: knee.x, y: knee.y },
        { x: ankle.x, y: ankle.y }
      );
    }

    function updateTags() {
      if (coachAngles.length > 0) {
        coachTag.textContent = "已錄製";
        coachTag.classList.remove("none");
        coachTag.classList.add("ok");
      } else {
        coachTag.textContent = "尚未錄製";
        coachTag.classList.remove("ok");
        coachTag.classList.add("none");
      }

      if (playerAngles.length > 0) {
        playerTag.textContent = "已錄製";
        playerTag.classList.remove("none");
        playerTag.classList.add("ok");
      } else {
        playerTag.textContent = "尚未錄製";
        playerTag.classList.remove("ok");
        playerTag.classList.add("none");
      }
    }

    function resampleArray(arr, targetLen) {
      if (arr.length === 0) return [];
      if (arr.length === targetLen) return arr.slice();

      const result = [];
      const step = (arr.length - 1) / (targetLen - 1);
      for (let i = 0; i < targetLen; i++) {
        const idx = i * step;
        const i0 = Math.floor(idx);
        const i1 = Math.min(arr.length - 1, i0 + 1);
        const t = idx - i0;
        const v = arr[i0] * (1 - t) + arr[i1] * t;
        result.push(v);
      }
      return result;
    }

    function computeSimilarity() {
      if (coachAngles.length < 5 || playerAngles.length < 5) {
        scoreEl.textContent = "";
        return;
      }

      const TARGET_LEN = 100;
      const coach = resampleArray(coachAngles, TARGET_LEN);
      const player = resampleArray(playerAngles, TARGET_LEN);

      let sumAbs = 0;
      for (let i = 0; i < TARGET_LEN; i++) {
        sumAbs += Math.abs(coach[i] - player[i]);
      }
      const mae = sumAbs / TARGET_LEN; // 平均角度差

      // 假設 0° 差距 = 100 分，90° 差距 = 0 分
      const maxDiff = 90;
      let score = Math.max(0, 100 - (mae / maxDiff) * 100);
      score = Math.round(score);

      let comment = "";
      if (score >= 85) comment = "幾乎跟教練一樣！";
      else if (score >= 70) comment = "動作很接近，再多練幾次就更好。";
      else if (score >= 50) comment = "有抓到大概節奏，可以微調深蹲深度與速度。";
      else comment = "差異比較大，可以跟著教練慢慢對齊動作。";

      scoreEl.textContent = `動作相似度：${score} 分（0–100）\n${comment}`;
    }

    async function poseLoop() {
      if (!detector) return requestAnimationFrame(poseLoop);

      let poses = [];
      try {
        poses = await detector.estimatePoses(video, { maxPoses: 1 });
      } catch (e) {
        console.error(e);
      }

      if (!poses || poses.length === 0) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        statusEl.textContent = "找不到人，請退後一點。";
        angleEl.textContent = "--";
        requestAnimationFrame(poseLoop);
        return;
      }

      const kp = poses[0].keypoints;
      drawPose(kp);

      const kneeAngle = computeKneeAngle(kp);
      if (kneeAngle == null) {
        angleEl.textContent = "--";
      } else {
        const ang = Math.round(kneeAngle);
        angleEl.textContent = ang.toString();
      }

      // 錄製中：把膝蓋角度塞進對應陣列
      if (mode === "recordCoach" || mode === "recordPlayer") {
        const now = performance.now();
        const elapsed = now - recordStartTime;

        if (elapsed <= RECORD_MS) {
          if (kneeAngle != null) {
            if (mode === "recordCoach") coachAngles.push(kneeAngle);
            else playerAngles.push(kneeAngle);
          }
          const secLeft = ((RECORD_MS - elapsed) / 1000).toFixed(1);
          statusEl.textContent =
            (mode === "recordCoach" ? "錄製教練動作中…" : "錄製挑戰者動作中…") +
            `（剩餘 ${secLeft} 秒）`;
        } else {
          // 錄製結束
          mode = "idle";
          statusEl.textContent = "錄製完成，可以預覽或錄製下一位。";
          updateTags();
          if (coachAngles.length > 0 && playerAngles.length > 0) {
            computeSimilarity();
          }
          recordCoachBtn.disabled = false;
          recordPlayerBtn.disabled = coachAngles.length === 0;
        }
      }

      requestAnimationFrame(poseLoop);
    }

    async function main() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        alert("瀏覽器不支援相機，請用 iPhone Safari 或新版 Chrome。");
        statusEl.textContent = "此瀏覽器不支援相機。";
        return;
      }

      await setupCamera();
      window.addEventListener("resize", resizeCanvas);

      statusEl.textContent = "載入姿勢模型中…";

      try {
        detector = await poseDetection.createDetector(
          poseDetection.SupportedModels.MoveNet,
          {
            modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
            runtime: "tfjs"
          }
        );
      } catch (e) {
        console.error(e);
        statusEl.textContent = "載入模型失敗：" + e.message;
        alert("載入姿勢模型失敗，可以稍後再試或換網路。");
        return;
      }

      statusEl.textContent = "準備好了，先錄製教練動作。";
      poseLoop();
    }

    // 按鈕事件
    recordCoachBtn.addEventListener("click", () => {
      coachAngles = [];
      playerAngles = playerAngles; // 不清空挑戰者，這裡只重錄教練
      scoreEl.textContent = "";
      mode = "recordCoach";
      recordStartTime = performance.now();
      recordCoachBtn.disabled = true;
      recordPlayerBtn.disabled = true;
      statusEl.textContent = "錄製教練動作中…";
      updateTags();
    });

    recordPlayerBtn.addEventListener("click", () => {
      playerAngles = [];
      scoreEl.textContent = "";
      mode = "recordPlayer";
      recordStartTime = performance.now();
      recordCoachBtn.disabled = true;
      recordPlayerBtn.disabled = true;
      statusEl.textContent = "錄製挑戰者動作中…";
      updateTags();
    });

    resetBtn.addEventListener("click", () => {
      coachAngles = [];
      playerAngles = [];
      mode = "idle";
      scoreEl.textContent = "";
      statusEl.textContent = "已清除紀錄，可以重新錄製教練動作。";
      recordCoachBtn.disabled = false;
      recordPlayerBtn.disabled = true;
      updateTags();
    });

    main();
  </script>
</body>
</html>
