<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>GameFit 3D 同步深蹲 Demo（Safari 修正版）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- TensorFlow.js + MoveNet -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: #020617;
      color: #e5e7eb;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      min-height: 100vh;
      padding: 12px;
      gap: 12px;
    }
    #video-container {
      position: relative;
      width: 100%;
      max-width: 420px;
      aspect-ratio: 9 / 16;
      background: #000;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid #1f2937;
    }
    #video, #overlay {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    #renderArea {
      width: 100%;
      max-width: 480px;
      height: 260px;
      border-radius: 12px;
      background: #1e293b;
      border: 1px solid #334155;
      overflow: hidden;
    }
  </style>
</head>

<body>
<h2>GameFit 3D 同步深蹲 Demo</h2>

<div id="video-container">
  <video id="video" playsinline></video>
  <canvas id="overlay"></canvas>
</div>

<div id="angle-label">左膝角度：--°</div>
<div id="renderArea"></div>

<!-- Three.js 用 ES Module（Safari 最穩） -->
<script type="module">

/* -------------------- 匯入 Three.js（iPhone 最穩定） -------------------- */
import * as THREE from "https://unpkg.com/three@0.150.0/build/three.module.js";
import { GLTFLoader } from "https://unpkg.com/three@0.150.0/examples/jsm/loaders/GLTFLoader.js";

/* -------------------- HTML 元件 -------------------- */
const video = document.getElementById("video");
const canvas = document.getElementById("overlay");
const ctx = canvas.getContext("2d");
const angleLabel = document.getElementById("angle-label");

/* -------------------- TensorFlow MoveNet -------------------- */
let detector = null;
let lastStream = null;
let lastKneeAngle = 0;

/* -------------------- 全身骨架連線設定 -------------------- */
const adjacentPairs = [
  ["left_shoulder", "right_shoulder"],
  ["left_shoulder", "left_elbow"],
  ["left_elbow", "left_wrist"],
  ["right_shoulder", "right_elbow"],
  ["right_elbow", "right_wrist"],
  ["left_shoulder", "left_hip"],
  ["right_shoulder", "right_hip"],
  ["left_hip", "right_hip"],
  ["left_hip", "left_knee"],
  ["left_knee", "left_ankle"],
  ["right_hip", "right_knee"],
  ["right_knee", "right_ankle"]
];

/* -------------------- 計算角度 -------------------- */
function angleBetween(a, b, c) {
  const ab = { x:a.x-b.x, y:a.y-b.y };
  const cb = { x:c.x-b.x, y:c.y-b.y };
  const dot = ab.x * cb.x + ab.y * cb.y;
  const magAB = Math.hypot(ab.x, ab.y);
  const magCB = Math.hypot(cb.x, cb.y);
  if (!magAB || !magCB) return 0;
  return Math.acos(dot / (magAB * magCB)) * 180 / Math.PI;
}

/* -------------------- 相機啟動 -------------------- */
async function setupCamera() {
  if (lastStream) lastStream.getTracks().forEach(t => t.stop());

  const stream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode: "environment" },
    audio: false
  });

  lastStream = stream;
  video.srcObject = stream;

  return new Promise(resolve => {
    video.onloadedmetadata = () => {
      video.play();
      resizeCanvas();
      resolve();
    };
  });
}

function resizeCanvas() {
  canvas.width = video.videoWidth || 360;
  canvas.height = video.videoHeight || 640;
}

/* -------------------- 2D 骨架畫線 -------------------- */
function drawPose(keypoints) {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if (!keypoints) return;

  const toScreen = kp => ({
    x: kp.x / video.videoWidth * canvas.width,
    y: kp.y / video.videoHeight * canvas.height
  });

  ctx.lineWidth = 4;
  ctx.strokeStyle = "#38bdf8";
  ctx.shadowColor = "#38bdf8";
  ctx.shadowBlur = 12;
  ctx.beginPath();

  adjacentPairs.forEach(([aName,bName]) => {
    const a = keypoints.find(k=>k.name===aName);
    const b = keypoints.find(k=>k.name===bName);
    if (!a || !b || a.score<0.3 || b.score<0.3) return;
    const sa = toScreen(a);
    const sb = toScreen(b);
    ctx.moveTo(sa.x, sa.y);
    ctx.lineTo(sb.x, sb.y);
  });
  ctx.stroke();

  keypoints.forEach(k => {
    if (k.score < 0.3) return;
    const {x,y} = toScreen(k);

    ctx.fillStyle = "rgba(56,189,248,0.25)";
    ctx.shadowColor = "#38bdf8";
    ctx.shadowBlur = 14;
    ctx.beginPath();
    ctx.arc(x,y,8,0,Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "#38bdf8";
    ctx.beginPath();
    ctx.arc(x,y,3.5,0,Math.PI*2);
    ctx.fill();
  });
}

/* -------------------- Three.js 3D 場景 -------------------- */
let scene, camera3D, renderer, model;

function init3D() {
  const area = document.getElementById("renderArea");

  renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(area.clientWidth, area.clientHeight);
  area.appendChild(renderer.domElement);

  scene = new THREE.Scene();
  scene.background = new THREE.Color("#0f172a");

  camera3D = new THREE.PerspectiveCamera(
    40,
    area.clientWidth/area.clientHeight,
    0.1,
    100
  );
  camera3D.position.set(0,1.5,3);
  scene.add(camera3D);

  const light = new THREE.DirectionalLight(0xffffff,1.2);
  light.position.set(2,4,3);
  scene.add(light);

  const loader = new GLTFLoader();
  loader.load(
    "https://threejs.org/examples/models/gltf/Soldier.glb",
    glb => {
      model = glb.scene;
      model.scale.set(1.2,1.2,1.2);
      scene.add(model);
    }
  );

  animate3D();
}

function animate3D() {
  requestAnimationFrame(animate3D);

  if (model) {
    const upLeg = model.getObjectByName("mixamorig_LeftUpLeg");
    const leg = model.getObjectByName("mixamorig_LeftLeg");

    if (upLeg) upLeg.rotation.x = THREE.MathUtils.degToRad(-lastKneeAngle * 0.4);
    if (leg) leg.rotation.x = THREE.MathUtils.degToRad(-lastKneeAngle * 0.6);
  }

  renderer.render(scene, camera3D);
}

/* -------------------- MoveNet 迴圈 -------------------- */
async function poseLoop() {
  if (!detector) {
    requestAnimationFrame(poseLoop);
    return;
  }

  let poses = [];
  try {
    poses = await detector.estimatePoses(video, { maxPoses: 1 });
  } catch(e){}

  if (poses.length === 0) {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    angleLabel.textContent = "左膝角度：--°（請退後）";
    requestAnimationFrame(poseLoop);
    return;
  }

  const kp = poses[0].keypoints;
  drawPose(kp);

  const hip = kp.find(k=>k.name==="left_hip");
  const knee = kp.find(k=>k.name==="left_knee");
  const ankle = kp.find(k=>k.name==="left_ankle");

  if (hip && knee && ankle &&
      hip.score>0.3 && knee.score>0.3 && ankle.score>0.3) {

    const kAngle = angleBetween(hip,knee,ankle);

    lastKneeAngle = lastKneeAngle * 0.8 + kAngle * 0.2;

    angleLabel.textContent = `左膝角度：${Math.round(lastKneeAngle)}°`;
  }

  requestAnimationFrame(poseLoop);
}

/* -------------------- Init -------------------- */
(async ()=>{

  await setupCamera();
  await tf.ready();

  detector = await poseDetection.createDetector(
    poseDetection.SupportedModels.MoveNet,
    {
      modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
      runtime: "tfjs"
    }
  );

  init3D();
  poseLoop();

})();
</script>

</body>
</html>
