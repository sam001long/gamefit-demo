<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>GameFit è‡‰éƒ¨éª¨æ¶ï¼‹è¡¨æƒ…åµæ¸¬ Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- TensorFlow.js + Face Landmarks -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection"></script>

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #020617;
      color: #e5e7eb;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 12px;
      gap: 10px;
      min-height: 100vh;
    }
    h1 { font-size: 18px; text-align: center; }
    #videoContainer {
      position: relative;
      width: 100%;
      max-width: 420px;
      aspect-ratio: 3 / 4;
      background: #000;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid #1f2937;
    }
    #video, #canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    #canvas { pointer-events: none; }
    #expression {
      font-size: 16px;
      color: #38bdf8;
      text-align: center;
      text-shadow: 0 0 8px #38bdf8;
    }
    #hint {
      font-size: 11px;
      color: #9ca3af;
      max-width: 420px;
      line-height: 1.4;
    }
  </style>
</head>

<body>
  <h1>è‡‰éƒ¨éª¨æ¶ï¼‹è¡¨æƒ…åµæ¸¬ Demo</h1>
  <div id="expression">è¡¨æƒ…ï¼š--</div>

  <div id="videoContainer">
    <video id="video" playsinline></video>
    <canvas id="canvas"></canvas>
  </div>

  <div id="hint">
    ä½¿ç”¨æ–¹å¼ï¼š<br>
    1. ä½¿ç”¨å‰é¡é ­ï¼ŒæŠŠè‡‰ç§»åˆ°ç•«é¢ä¸­å¤®ã€‚<br>
    2. å˜´å·´å¼µå¤§ã€å¾®ç¬‘ã€æ”¾é¬†è¡¨æƒ…ï¼Œè§€å¯Ÿä¸Šæ–¹æ–‡å­—è®ŠåŒ–ã€‚<br>
    3. è¢å¹•ä¸Šçš„è—è‰²é»ç‚ºè‡‰éƒ¨éª¨æ¶ç‰¹å¾µé»ã€‚<br>
  </div>

  <script>
    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const expressionLabel = document.getElementById("expression");

    let detector = null;

    async function setupCamera() {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "user" }, // å‰é¡é ­
        audio: false
      });
      video.srcObject = stream;
      return new Promise(resolve => {
        video.onloadedmetadata = () => {
          video.play();
          resizeCanvas();
          resolve();
        };
      });
    }

    function resizeCanvas() {
      canvas.width = video.videoWidth || 360;
      canvas.height = video.videoHeight || 480;
    }

    function classifyExpression(keypoints) {
      if (!keypoints || keypoints.length === 0) return "--";

      const byName = (name) => keypoints.find(k => k.name === name);

      const upperLip = byName("lipsUpperOuter");
      const lowerLip = byName("lipsLowerOuter");
      const leftEyeUpper = byName("leftEyeUpper0");
      const leftEyeLower = byName("leftEyeLower0");
      const rightEyeUpper = byName("rightEyeUpper0");
      const rightEyeLower = byName("rightEyeLower0");

      let mouthOpen = 0;
      if (upperLip && lowerLip) mouthOpen = Math.abs(lowerLip.y - upperLip.y);

      let leftEyeOpen = 0;
      let rightEyeOpen = 0;
      if (leftEyeUpper && leftEyeLower) {
        leftEyeOpen = Math.abs(leftEyeLower.y - leftEyeUpper.y);
      }
      if (rightEyeUpper && rightEyeLower) {
        rightEyeOpen = Math.abs(rightEyeLower.y - rightEyeUpper.y);
      }

      if (mouthOpen > 10) return "ğŸ˜® é©šè¨";
      if (mouthOpen > 5)  return "ğŸ˜† å¤§ç¬‘";
      if (mouthOpen < 2 && leftEyeOpen < 3 && rightEyeOpen < 3) return "ğŸ˜ æ”¾é¬† / ä¸­æ€§";
      return "ğŸ™‚ å¾®ç¬‘";
    }

    function drawFace(keypoints) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!keypoints || keypoints.length === 0) return;

      ctx.fillStyle = "#38bdf8";
      ctx.shadowColor = "#38bdf8";
      ctx.shadowBlur = 8;

      keypoints.forEach(p => {
        const x = p.x;
        const y = p.y;
        ctx.beginPath();
        ctx.arc(x, y, 2, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    async function loop() {
      if (!detector) {
        requestAnimationFrame(loop);
        return;
      }

      let faces = [];
      try {
        faces = await detector.estimateFaces(video, {
          flipHorizontal: true
        });
      } catch (e) {
        console.error(e);
      }

      if (!faces || faces.length === 0) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        expressionLabel.textContent = "è¡¨æƒ…ï¼š--";
        requestAnimationFrame(loop);
        return;
      }

      const face = faces[0];
      const keypoints = face.keypoints || [];
      drawFace(keypoints);

      const expr = classifyExpression(keypoints);
      expressionLabel.textContent = "è¡¨æƒ…ï¼š" + expr;

      requestAnimationFrame(loop);
    }

    async function main() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        alert("ç€è¦½å™¨ä¸æ”¯æ´ç›¸æ©Ÿï¼Œè«‹æ”¹ç”¨ iPhone Safari æˆ–æ–°ç‰ˆ Chromeã€‚");
        return;
      }

      await setupCamera();
      window.addEventListener("resize", resizeCanvas);

      await tf.ready();

      detector = await faceLandmarksDetection.createDetector(
        faceLandmarksDetection.SupportedModels.MediaPipeFaceMesh,
        {
          runtime: "tfjs"
        }
      );

      loop();
    }

    main().catch(err => {
      console.error(err);
      alert("åˆå§‹åŒ–å¤±æ•—ï¼š" + err.message);
    });
  </script>
</body>
</html>