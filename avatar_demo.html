<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>GameFit Avatar åŒæ­¥æ·±è¹² Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- TensorFlow.js + Pose Detection -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: #020617;
      color: #e5e7eb;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      min-height: 100vh;
      padding: 12px;
      gap: 10px;
    }
    h1 { font-size: 18px; text-align: center; }

    #video-container {
      position: relative;
      width: 100%;
      max-width: 420px;
      aspect-ratio: 9 / 16;
      background: #000;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid #1f2937;
    }
    #video, #overlay {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    #overlay { pointer-events: none; }

    #angle-label {
      font-size: 13px;
      text-align: center;
    }

    #avatar-container {
      width: 100%;
      max-width: 420px;
      height: 220px;
      border-radius: 12px;
      background: #0b1120;
      border: 1px solid #1f2937;
      overflow: hidden;
    }

    #hint {
      font-size: 11px;
      color: #9ca3af;
      max-width: 420px;
      line-height: 1.4;
    }
  </style>
</head>
<body>
  <h1>GameFit Avatar åŒæ­¥æ·±è¹² Demo</h1>

  <div id="video-container">
    <video id="video" playsinline></video>
    <canvas id="overlay"></canvas>
  </div>

  <div id="angle-label">å·¦è†è§’åº¦ï¼š--Â°</div>

  <div id="avatar-container">
    <canvas id="avatarCanvas"></canvas>
  </div>

  <div id="hint">
    ä½¿ç”¨æ–¹å¼ï¼š<br>
    1. ç”¨ <b>å¾Œé¡é ­</b> å°è‘—è‡ªå·±ï¼Œé€€å¾Œä¸€é»è®“é«–é—œç¯€ï½è†è“‹ï½è…³è¸éƒ½å…¥é¡ã€‚<br>
    2. è¦ªè‡ªåšæ·±è¹²ï¼ˆç«™ç›´ â†’ è¹²ä¸‹ â†’ èµ·ä¾†ï¼‰ï¼Œæœƒæ¯”å°è‘—é›»è¦–æ›´å®¹æ˜“çœ‹åˆ°å·®ç•°ã€‚<br>
    3. ä¸Šæ–¹é¡¯ç¤ºéª¨æ¶èˆ‡è†è“‹è§’åº¦ï¼›ä¸‹æ–¹ Avatar æœƒè·Ÿè‘—åŒæ­¥è¹²ä¸‹ã€ç«™èµ·ã€‚<br>
  </div>

  <script>
    const video = document.getElementById("video");
    const canvas = document.getElementById("overlay");
    const ctx = canvas.getContext("2d");
    const angleLabel = document.getElementById("angle-label");

    const avatarCanvas = document.getElementById("avatarCanvas");
    const actx = avatarCanvas.getContext("2d");

    let detector = null;
    let lastStream = null;
    let lastKneeAngle = 170; // å¹³æ»‘å¾Œçš„è†è“‹è§’åº¦

    const adjacentPairs = [
      ["left_shoulder", "right_shoulder"],
      ["left_shoulder", "left_elbow"],
      ["left_elbow", "left_wrist"],
      ["right_shoulder", "right_elbow"],
      ["right_elbow", "right_wrist"],
      ["left_shoulder", "left_hip"],
      ["right_shoulder", "right_hip"],
      ["left_hip", "right_hip"],
      ["left_hip", "left_knee"],
      ["left_knee", "left_ankle"],
      ["right_hip", "right_knee"],
      ["right_knee", "right_ankle"]
    ];

    function angleBetween(a, b, c) {
      const ab = { x: a.x - b.x, y: a.y - b.y };
      const cb = { x: c.x - b.x, y: c.y - b.y };
      const dot = ab.x * cb.x + ab.y * cb.y;
      const magAB = Math.hypot(ab.x, ab.y);
      const magCB = Math.hypot(cb.x, cb.y);
      if (!magAB || !magCB) return 0;
      const cos = dot / (magAB * magCB);
      const clamped = Math.max(-1, Math.min(1, cos));
      return (Math.acos(clamped) * 180) / Math.PI;
    }

    async function setupCamera() {
      if (lastStream) lastStream.getTracks().forEach(t => t.stop());

      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "environment" }, // å¾Œé¡é ­
        audio: false
      });

      lastStream = stream;
      video.srcObject = stream;

      return new Promise(resolve => {
        video.onloadedmetadata = () => {
          video.play();
          resizeCanvas();
          resizeAvatarCanvas();
          resolve();
        };
      });
    }

    function resizeCanvas() {
      canvas.width = video.videoWidth || 360;
      canvas.height = video.videoHeight || 640;
    }

    function resizeAvatarCanvas() {
      const rect = document.getElementById("avatar-container").getBoundingClientRect();
      avatarCanvas.width = rect.width;
      avatarCanvas.height = rect.height;
    }

    function drawPose(keypoints) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!keypoints || !video.videoWidth || !video.videoHeight) return;

      const toScreen = (kp) => ({
        x: (kp.x / video.videoWidth) * canvas.width,
        y: (kp.y / video.videoHeight) * canvas.height
      });

      ctx.save();
      ctx.lineWidth = 4;
      ctx.strokeStyle = "#38bdf8";
      ctx.shadowColor = "#38bdf8";
      ctx.shadowBlur = 12;
      ctx.beginPath();
      adjacentPairs.forEach(([aName, bName]) => {
        const a = keypoints.find(k => k.name === aName || k.part === aName);
        const b = keypoints.find(k => k.name === bName || k.part === bName);
        if (!a || !b || a.score < 0.3 || b.score < 0.3) return;
        const sa = toScreen(a);
        const sb = toScreen(b);
        ctx.moveTo(sa.x, sa.y);
        ctx.lineTo(sb.x, sb.y);
      });
      ctx.stroke();
      ctx.restore();

      keypoints.forEach(kp => {
        if (kp.score < 0.3) return;
        const { x, y } = toScreen(kp);

        ctx.save();
        ctx.fillStyle = "rgba(56,189,248,0.25)";
        ctx.shadowColor = "#38bdf8";
        ctx.shadowBlur = 14;
        ctx.beginPath();
        ctx.arc(x, y, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        ctx.save();
        ctx.fillStyle = "#38bdf8";
        ctx.beginPath();
        ctx.arc(x, y, 3.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }

    function getPoint(keypoints, name, fallbackIndexArray = []) {
      let pt = keypoints.find(k => k.name === name || k.part === name);
      if (pt) return pt;
      for (const idx of fallbackIndexArray) {
        if (keypoints[idx]) return keypoints[idx];
      }
      return null;
    }

    function computeKneeAngle(keypoints) {
      // å·¦è…³å„ªå…ˆï¼Œä¸è¡Œå°±ç”¨å³è…³
      let hip   = getPoint(keypoints, "left_hip",   [11, 23]);
      let knee  = getPoint(keypoints, "left_knee",  [13, 25]);
      let ankle = getPoint(keypoints, "left_ankle", [15, 27]);

      if (!hip || !knee || !ankle ||
          hip.score < 0.2 || knee.score < 0.2 || ankle.score < 0.2) {
        hip   = getPoint(keypoints, "right_hip",   [12, 24]);
        knee  = getPoint(keypoints, "right_knee",  [14, 26]);
        ankle = getPoint(keypoints, "right_ankle", [16, 28]);
      }

      if (!hip || !knee || !ankle ||
          hip.score < 0.2 || knee.score < 0.2 || ankle.score < 0.2) {
        return null;
      }

      return angleBetween(
        { x: hip.x,   y: hip.y },
        { x: knee.x,  y: knee.y },
        { x: ankle.x, y: ankle.y }
      );
    }

    function drawAvatar(angleDeg) {
      const w = avatarCanvas.width;
      const h = avatarCanvas.height;
      actx.clearRect(0, 0, w, h);

      actx.fillStyle = "#020617";
      actx.fillRect(0, 0, w, h);
      actx.fillStyle = "#111827";
      actx.fillRect(0, h * 0.7, w, h * 0.3);

      const centerX = w * 0.5;
      const hipYBase = h * 0.6;

      // ğŸ”¥ æ”¾å¤§æ·±è¹²æ•ˆæœï¼šç”¨ 80~170 åº¦ä½œæ˜ å°„
      const clamped = Math.max(80, Math.min(170, angleDeg || 170));
      const squatAmount = (170 - clamped) / (170 - 80); // 0~1

      const hipY = hipYBase + squatAmount * 45; // å¤šè¹²ä¸€é»ï¼Œå‹•ä½œæ˜é¡¯

      const torsoLen = 50;
      const legUpperLen = 42;
      const legLowerLen = 42;

      const headR = 16;
      const headY = hipY - torsoLen - headR * 1.8;
      actx.fillStyle = "#f97316";
      actx.beginPath();
      actx.arc(centerX, headY, headR, 0, Math.PI * 2);
      actx.fill();

      const shoulderY = hipY - torsoLen;
      actx.strokeStyle = "#38bdf8";
      actx.lineWidth = 5;
      actx.lineCap = "round";
      actx.beginPath();
      actx.moveTo(centerX, shoulderY);
      actx.lineTo(centerX, hipY);
      actx.stroke();

      const armLen = 38;
      actx.beginPath();
      actx.moveTo(centerX, shoulderY + 8);
      actx.lineTo(centerX - armLen, shoulderY + 20);
      actx.moveTo(centerX, shoulderY + 8);
      actx.lineTo(centerX + armLen, shoulderY + 20);
      actx.stroke();

      const leftHip = { x: centerX - 12, y: hipY };
      const rightHip = { x: centerX + 12, y: hipY };

      const upperBaseAngle = Math.PI * 0.5;
      const upperOffset = squatAmount * 0.7;   // å¤§è…¿å¾€å‰è§’åº¦
      const kneeBend = squatAmount * 1.4;      // å°è…¿å½æ›²

      const leftUpperAngle = upperBaseAngle - upperOffset;
      const leftKnee = {
        x: leftHip.x + Math.cos(leftUpperAngle) * legUpperLen,
        y: leftHip.y + Math.sin(leftUpperAngle) * legUpperLen
      };

      const leftLowerAngle = leftUpperAngle + kneeBend;
      const leftAnkle = {
        x: leftKnee.x + Math.cos(leftLowerAngle) * legLowerLen,
        y: leftKnee.y + Math.sin(leftLowerAngle) * legLowerLen
      };

      const rightUpperAngle = upperBaseAngle - upperOffset * 0.8;
      const rightKnee = {
        x: rightHip.x + Math.cos(rightUpperAngle) * legUpperLen,
        y: rightHip.y + Math.sin(rightUpperAngle) * legUpperLen
      };
      const rightLowerAngle = rightUpperAngle + kneeBend * 0.9;
      const rightAnkle = {
        x: rightKnee.x + Math.cos(rightLowerAngle) * legLowerLen,
        y: rightKnee.y + Math.sin(rightLowerAngle) * legLowerLen
      };

      actx.strokeStyle = "#22c55e";
      actx.lineWidth = 5;
      actx.beginPath();
      actx.moveTo(leftHip.x, leftHip.y);
      actx.lineTo(leftKnee.x, leftKnee.y);
      actx.lineTo(leftAnkle.x, leftAnkle.y);
      actx.moveTo(rightHip.x, rightHip.y);
      actx.lineTo(rightKnee.x, rightKnee.y);
      actx.lineTo(rightAnkle.x, rightAnkle.y);
      actx.stroke();

      actx.lineWidth = 4;
      actx.beginPath();
      actx.moveTo(leftAnkle.x - 11, leftAnkle.y + 4);
      actx.lineTo(leftAnkle.x + 11, leftAnkle.y + 4);
      actx.moveTo(rightAnkle.x - 11, rightAnkle.y + 4);
      actx.lineTo(rightAnkle.x + 11, rightAnkle.y + 4);
      actx.stroke();

      // åœ¨å³ä¸Šè§’é¡¯ç¤ºç›®å‰è§’åº¦ & æ·±è¹²ç™¾åˆ†æ¯”ï¼Œæ–¹ä¾¿ä½ ç¢ºèªæœ‰åœ¨æ›´æ–°
      actx.fillStyle = "#e5e7eb";
      actx.font = "11px -apple-system, BlinkMacSystemFont, sans-serif";
      actx.textAlign = "right";
      actx.fillText(`è§’åº¦: ${Math.round(angleDeg)}Â°`, w - 8, 14);
      actx.fillText(`æ·±è¹²: ${Math.round(squatAmount * 100)}%`, w - 8, 28);
    }

    async function poseLoop() {
      if (!detector) {
        requestAnimationFrame(poseLoop);
        return;
      }

      let poses = [];
      try {
        poses = await detector.estimatePoses(video, { maxPoses: 1 });
      } catch (e) {
        console.error(e);
      }

      if (!poses || poses.length === 0) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        angleLabel.textContent = "å·¦è†è§’åº¦ï¼š--Â°ï¼ˆè«‹é€€å¾Œä¸€é»è®“ä¸‹åŠèº«å…¥é¡ï¼‰";
        drawAvatar(lastKneeAngle);
        requestAnimationFrame(poseLoop);
        return;
      }

      const kp = poses[0].keypoints;
      drawPose(kp);

      const ang = computeKneeAngle(kp);
      if (ang == null) {
        angleLabel.textContent = "å·¦è†è§’åº¦ï¼š--Â°ï¼ˆåµæ¸¬ä¸åˆ°è…¿éƒ¨ï¼Œè«‹å†èª¿æ•´ä½ç½®ï¼‰";
      } else {
        const alpha = 0.85; // å¹³æ»‘ä¿‚æ•¸
        lastKneeAngle = lastKneeAngle * alpha + ang * (1 - alpha);
        angleLabel.textContent = "å·¦è†è§’åº¦ï¼š" + Math.round(lastKneeAngle) + "Â°";
      }

      drawAvatar(lastKneeAngle);
      requestAnimationFrame(poseLoop);
    }

    async function main() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        alert("ç€è¦½å™¨ä¸æ”¯æ´ç›¸æ©Ÿï¼Œè«‹æ”¹ç”¨ iPhone Safari æˆ–æ–°ç‰ˆ Chromeã€‚");
        return;
      }

      await setupCamera();
      window.addEventListener("resize", () => {
        resizeCanvas();
        resizeAvatarCanvas();
      });

      await tf.ready();

      detector = await poseDetection.createDetector(
        poseDetection.SupportedModels.MoveNet,
        {
          modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
          runtime: "tfjs"
        }
      );

      poseLoop();
    }

    main().catch(err => {
      console.error(err);
      alert("åˆå§‹åŒ–å¤±æ•—ï¼š" + err.message);
    });
  </script>
</body>
</html>